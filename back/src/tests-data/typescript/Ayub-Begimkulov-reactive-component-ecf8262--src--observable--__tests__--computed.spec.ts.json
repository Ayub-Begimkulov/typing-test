{"type":"typescript","text":"import { observable /* observe */ } from \"..\";\nimport { computed } from \"../computed\";\n\ndescribe(\"reactivity/computed\", () => {\n  it(\"should return updated value\", () => {\n    const value = observable({ foo: 0 });\n    const cValue = computed(() => value.foo);\n    expect(cValue.value).toBe(0);\n    value.foo = 1;\n    expect(cValue.value).toBe(1);\n  });\n\n  // it(\"should compute lazily\", () => {\n  //   const value = observable<{ foo?: number }>({});\n  //   const getter = jest.fn(() => value.foo);\n  //   const cValue = computed(getter);\n\n  //   // lazy\n  //   expect(getter).not.toHaveBeenCalled();\n\n  //   expect(cValue.value).toBe(undefined);\n  //   expect(getter).toHaveBeenCalledTimes(1);\n\n  //   // should not compute again\n  //   cValue.value;\n  //   expect(getter).toHaveBeenCalledTimes(1);\n\n  //   // should not compute until needed\n  //   value.foo = 1;\n  //   expect(getter).toHaveBeenCalledTimes(1);\n\n  //   // now it should compute\n  //   expect(cValue.value).toBe(1);\n  //   expect(getter).toHaveBeenCalledTimes(2);\n\n  //   // should not compute again\n  //   cValue.value;\n  //   expect(getter).toHaveBeenCalledTimes(2);\n  // });\n\n  // it(\"should trigger effect\", () => {\n  //   const value = observable<{ foo?: number }>({});\n  //   const cValue = computed(() => value.foo);\n  //   let dummy;\n  //   effect(() => {\n  //     dummy = cValue.value;\n  //   });\n  //   expect(dummy).toBe(undefined);\n  //   value.foo = 1;\n  //   expect(dummy).toBe(1);\n  // });\n\n  // it(\"should work when chained\", () => {\n  //   const value = observable({ foo: 0 });\n  //   const c1 = computed(() => value.foo);\n  //   const c2 = computed(() => c1.value + 1);\n  //   expect(c2.value).toBe(1);\n  //   expect(c1.value).toBe(0);\n  //   value.foo++;\n  //   expect(c2.value).toBe(2);\n  //   expect(c1.value).toBe(1);\n  // });\n\n  // it(\"should trigger effect when chained\", () => {\n  //   const value = observable({ foo: 0 });\n  //   const getter1 = jest.fn(() => value.foo);\n  //   const getter2 = jest.fn(() => {\n  //     return c1.value + 1;\n  //   });\n  //   const c1 = computed(getter1);\n  //   const c2 = computed(getter2);\n\n  //   let dummy;\n  //   effect(() => {\n  //     dummy = c2.value;\n  //   });\n  //   expect(dummy).toBe(1);\n  //   expect(getter1).toHaveBeenCalledTimes(1);\n  //   expect(getter2).toHaveBeenCalledTimes(1);\n  //   value.foo++;\n  //   expect(dummy).toBe(2);\n  //   // should not result in duplicate calls\n  //   expect(getter1).toHaveBeenCalledTimes(2);\n  //   expect(getter2).toHaveBeenCalledTimes(2);\n  // });\n\n  // it(\"should trigger effect when chained (mixed invocations)\", () => {\n  //   const value = observable({ foo: 0 });\n  //   const getter1 = jest.fn(() => value.foo);\n  //   const getter2 = jest.fn(() => {\n  //     return c1.value + 1;\n  //   });\n  //   const c1 = computed(getter1);\n  //   const c2 = computed(getter2);\n\n  //   let dummy;\n  //   effect(() => {\n  //     dummy = c1.value + c2.value;\n  //   });\n  //   expect(dummy).toBe(1);\n\n  //   expect(getter1).toHaveBeenCalledTimes(1);\n  //   expect(getter2).toHaveBeenCalledTimes(1);\n  //   value.foo++;\n  //   expect(dummy).toBe(3);\n  //   // should not result in duplicate calls\n  //   expect(getter1).toHaveBeenCalledTimes(2);\n  //   expect(getter2).toHaveBeenCalledTimes(2);\n  // });\n\n  // it(\"should no longer update when stopped\", () => {\n  //   const value = observable<{ foo?: number }>({});\n  //   const cValue = computed(() => value.foo);\n  //   let dummy;\n  //   effect(() => {\n  //     dummy = cValue.value;\n  //   });\n  //   expect(dummy).toBe(undefined);\n  //   value.foo = 1;\n  //   expect(dummy).toBe(1);\n  //   stop(cValue.effect);\n  //   value.foo = 2;\n  //   expect(dummy).toBe(1);\n  // });\n\n  // it(\"should support setter\", () => {\n  //   const n = ref(1);\n  //   const plusOne = computed({\n  //     get: () => n.value + 1,\n  //     set: val => {\n  //       n.value = val - 1;\n  //     },\n  //   });\n\n  //   expect(plusOne.value).toBe(2);\n  //   n.value++;\n  //   expect(plusOne.value).toBe(3);\n\n  //   plusOne.value = 0;\n  //   expect(n.value).toBe(-1);\n  // });\n\n  // it(\"should trigger effect w/ setter\", () => {\n  //   const n = ref(1);\n  //   const plusOne = computed({\n  //     get: () => n.value + 1,\n  //     set: val => {\n  //       n.value = val - 1;\n  //     },\n  //   });\n\n  //   let dummy;\n  //   effect(() => {\n  //     dummy = n.value;\n  //   });\n  //   expect(dummy).toBe(1);\n\n  //   plusOne.value = 0;\n  //   expect(dummy).toBe(-1);\n  // });\n\n  // it(\"should warn if trying to set a readonly computed\", () => {\n  //   const n = ref(1);\n  //   const plusOne = computed(() => n.value + 1);\n  //   (plusOne as WritableComputedRef<number>).value++; // Type cast to prevent TS from preventing the error\n\n  //   expect(\n  //     \"Write operation failed: computed value is readonly\"\n  //   ).toHaveBeenWarnedLast();\n  // });\n});","words":[{"text":"import","type":"Keyword","range":[0,6]},{"text":"observable","type":"Identifier","range":[9,19]},{"text":" observe ","type":"Block","range":[20,33]},{"text":"from","type":"Identifier","range":[36,40]},{"text":"\"..\"","type":"String","range":[41,45]},{"text":"import","type":"Keyword","range":[47,53]},{"text":"computed","type":"Identifier","range":[56,64]},{"text":"from","type":"Identifier","range":[67,71]},{"text":"\"../computed\"","type":"String","range":[72,85]},{"text":"describe","type":"Identifier","range":[88,96]},{"text":"\"reactivity/computed\"","type":"String","range":[97,118]},{"text":"it","type":"Identifier","range":[130,132]},{"text":"\"should return updated value\"","type":"String","range":[133,162]},{"text":"const","type":"Keyword","range":[176,181]},{"text":"value","type":"Identifier","range":[182,187]},{"text":"observable","type":"Identifier","range":[190,200]},{"text":"foo","type":"Identifier","range":[203,206]},{"text":"0","type":"Numeric","range":[208,209]},{"text":"const","type":"Keyword","range":[218,223]},{"text":"cValue","type":"Identifier","range":[224,230]},{"text":"computed","type":"Identifier","range":[233,241]},{"text":"value","type":"Identifier","range":[248,253]},{"text":"foo","type":"Identifier","range":[254,257]},{"text":"expect","type":"Identifier","range":[264,270]},{"text":"cValue","type":"Identifier","range":[271,277]},{"text":"value","type":"Identifier","range":[278,283]},{"text":"toBe","type":"Identifier","range":[285,289]},{"text":"0","type":"Numeric","range":[290,291]},{"text":"value","type":"Identifier","range":[298,303]},{"text":"foo","type":"Identifier","range":[304,307]},{"text":"1","type":"Numeric","range":[310,311]},{"text":"expect","type":"Identifier","range":[317,323]},{"text":"cValue","type":"Identifier","range":[324,330]},{"text":"value","type":"Identifier","range":[331,336]},{"text":"toBe","type":"Identifier","range":[338,342]},{"text":"1","type":"Numeric","range":[343,344]},{"text":" it(\"should compute lazily\", () => {","type":"Line","range":[356,394]},{"text":"   const value = observable<{ foo?: number }>({});","type":"Line","range":[397,449]},{"text":"   const getter = jest.fn(() => value.foo);","type":"Line","range":[452,497]},{"text":"   const cValue = computed(getter);","type":"Line","range":[500,537]},{"text":"   // lazy","type":"Line","range":[541,553]},{"text":"   expect(getter).not.toHaveBeenCalled();","type":"Line","range":[556,599]},{"text":"   expect(cValue.value).toBe(undefined);","type":"Line","range":[603,645]},{"text":"   expect(getter).toHaveBeenCalledTimes(1);","type":"Line","range":[648,693]},{"text":"   // should not compute again","type":"Line","range":[697,729]},{"text":"   cValue.value;","type":"Line","range":[732,750]},{"text":"   expect(getter).toHaveBeenCalledTimes(1);","type":"Line","range":[753,798]},{"text":"   // should not compute until needed","type":"Line","range":[802,841]},{"text":"   value.foo = 1;","type":"Line","range":[844,863]},{"text":"   expect(getter).toHaveBeenCalledTimes(1);","type":"Line","range":[866,911]},{"text":"   // now it should compute","type":"Line","range":[915,944]},{"text":"   expect(cValue.value).toBe(1);","type":"Line","range":[947,981]},{"text":"   expect(getter).toHaveBeenCalledTimes(2);","type":"Line","range":[984,1029]},{"text":"   // should not compute again","type":"Line","range":[1033,1065]},{"text":"   cValue.value;","type":"Line","range":[1068,1086]},{"text":"   expect(getter).toHaveBeenCalledTimes(2);","type":"Line","range":[1089,1134]},{"text":" });","type":"Line","range":[1137,1143]},{"text":" it(\"should trigger effect\", () => {","type":"Line","range":[1147,1185]},{"text":"   const value = observable<{ foo?: number }>({});","type":"Line","range":[1188,1240]},{"text":"   const cValue = computed(() => value.foo);","type":"Line","range":[1243,1289]},{"text":"   let dummy;","type":"Line","range":[1292,1307]},{"text":"   effect(() => {","type":"Line","range":[1310,1329]},{"text":"     dummy = cValue.value;","type":"Line","range":[1332,1360]},{"text":"   });","type":"Line","range":[1363,1371]},{"text":"   expect(dummy).toBe(undefined);","type":"Line","range":[1374,1409]},{"text":"   value.foo = 1;","type":"Line","range":[1412,1431]},{"text":"   expect(dummy).toBe(1);","type":"Line","range":[1434,1461]},{"text":" });","type":"Line","range":[1464,1470]},{"text":" it(\"should work when chained\", () => {","type":"Line","range":[1474,1515]},{"text":"   const value = observable({ foo: 0 });","type":"Line","range":[1518,1560]},{"text":"   const c1 = computed(() => value.foo);","type":"Line","range":[1563,1605]},{"text":"   const c2 = computed(() => c1.value + 1);","type":"Line","range":[1608,1653]},{"text":"   expect(c2.value).toBe(1);","type":"Line","range":[1656,1686]},{"text":"   expect(c1.value).toBe(0);","type":"Line","range":[1689,1719]},{"text":"   value.foo++;","type":"Line","range":[1722,1739]},{"text":"   expect(c2.value).toBe(2);","type":"Line","range":[1742,1772]},{"text":"   expect(c1.value).toBe(1);","type":"Line","range":[1775,1805]},{"text":" });","type":"Line","range":[1808,1814]},{"text":" it(\"should trigger effect when chained\", () => {","type":"Line","range":[1818,1869]},{"text":"   const value = observable({ foo: 0 });","type":"Line","range":[1872,1914]},{"text":"   const getter1 = jest.fn(() => value.foo);","type":"Line","range":[1917,1963]},{"text":"   const getter2 = jest.fn(() => {","type":"Line","range":[1966,2002]},{"text":"     return c1.value + 1;","type":"Line","range":[2005,2032]},{"text":"   });","type":"Line","range":[2035,2043]},{"text":"   const c1 = computed(getter1);","type":"Line","range":[2046,2080]},{"text":"   const c2 = computed(getter2);","type":"Line","range":[2083,2117]},{"text":"   let dummy;","type":"Line","range":[2121,2136]},{"text":"   effect(() => {","type":"Line","range":[2139,2158]},{"text":"     dummy = c2.value;","type":"Line","range":[2161,2185]},{"text":"   });","type":"Line","range":[2188,2196]},{"text":"   expect(dummy).toBe(1);","type":"Line","range":[2199,2226]},{"text":"   expect(getter1).toHaveBeenCalledTimes(1);","type":"Line","range":[2229,2275]},{"text":"   expect(getter2).toHaveBeenCalledTimes(1);","type":"Line","range":[2278,2324]},{"text":"   value.foo++;","type":"Line","range":[2327,2344]},{"text":"   expect(dummy).toBe(2);","type":"Line","range":[2347,2374]},{"text":"   // should not result in duplicate calls","type":"Line","range":[2377,2421]},{"text":"   expect(getter1).toHaveBeenCalledTimes(2);","type":"Line","range":[2424,2470]},{"text":"   expect(getter2).toHaveBeenCalledTimes(2);","type":"Line","range":[2473,2519]},{"text":" });","type":"Line","range":[2522,2528]},{"text":" it(\"should trigger effect when chained (mixed invocations)\", () => {","type":"Line","range":[2532,2603]},{"text":"   const value = observable({ foo: 0 });","type":"Line","range":[2606,2648]},{"text":"   const getter1 = jest.fn(() => value.foo);","type":"Line","range":[2651,2697]},{"text":"   const getter2 = jest.fn(() => {","type":"Line","range":[2700,2736]},{"text":"     return c1.value + 1;","type":"Line","range":[2739,2766]},{"text":"   });","type":"Line","range":[2769,2777]},{"text":"   const c1 = computed(getter1);","type":"Line","range":[2780,2814]},{"text":"   const c2 = computed(getter2);","type":"Line","range":[2817,2851]},{"text":"   let dummy;","type":"Line","range":[2855,2870]},{"text":"   effect(() => {","type":"Line","range":[2873,2892]},{"text":"     dummy = c1.value + c2.value;","type":"Line","range":[2895,2930]},{"text":"   });","type":"Line","range":[2933,2941]},{"text":"   expect(dummy).toBe(1);","type":"Line","range":[2944,2971]},{"text":"   expect(getter1).toHaveBeenCalledTimes(1);","type":"Line","range":[2975,3021]},{"text":"   expect(getter2).toHaveBeenCalledTimes(1);","type":"Line","range":[3024,3070]},{"text":"   value.foo++;","type":"Line","range":[3073,3090]},{"text":"   expect(dummy).toBe(3);","type":"Line","range":[3093,3120]},{"text":"   // should not result in duplicate calls","type":"Line","range":[3123,3167]},{"text":"   expect(getter1).toHaveBeenCalledTimes(2);","type":"Line","range":[3170,3216]},{"text":"   expect(getter2).toHaveBeenCalledTimes(2);","type":"Line","range":[3219,3265]},{"text":" });","type":"Line","range":[3268,3274]},{"text":" it(\"should no longer update when stopped\", () => {","type":"Line","range":[3278,3331]},{"text":"   const value = observable<{ foo?: number }>({});","type":"Line","range":[3334,3386]},{"text":"   const cValue = computed(() => value.foo);","type":"Line","range":[3389,3435]},{"text":"   let dummy;","type":"Line","range":[3438,3453]},{"text":"   effect(() => {","type":"Line","range":[3456,3475]},{"text":"     dummy = cValue.value;","type":"Line","range":[3478,3506]},{"text":"   });","type":"Line","range":[3509,3517]},{"text":"   expect(dummy).toBe(undefined);","type":"Line","range":[3520,3555]},{"text":"   value.foo = 1;","type":"Line","range":[3558,3577]},{"text":"   expect(dummy).toBe(1);","type":"Line","range":[3580,3607]},{"text":"   stop(cValue.effect);","type":"Line","range":[3610,3635]},{"text":"   value.foo = 2;","type":"Line","range":[3638,3657]},{"text":"   expect(dummy).toBe(1);","type":"Line","range":[3660,3687]},{"text":" });","type":"Line","range":[3690,3696]},{"text":" it(\"should support setter\", () => {","type":"Line","range":[3700,3738]},{"text":"   const n = ref(1);","type":"Line","range":[3741,3763]},{"text":"   const plusOne = computed({","type":"Line","range":[3766,3797]},{"text":"     get: () => n.value + 1,","type":"Line","range":[3800,3830]},{"text":"     set: val => {","type":"Line","range":[3833,3853]},{"text":"       n.value = val - 1;","type":"Line","range":[3856,3883]},{"text":"     },","type":"Line","range":[3886,3895]},{"text":"   });","type":"Line","range":[3898,3906]},{"text":"   expect(plusOne.value).toBe(2);","type":"Line","range":[3910,3945]},{"text":"   n.value++;","type":"Line","range":[3948,3963]},{"text":"   expect(plusOne.value).toBe(3);","type":"Line","range":[3966,4001]},{"text":"   plusOne.value = 0;","type":"Line","range":[4005,4028]},{"text":"   expect(n.value).toBe(-1);","type":"Line","range":[4031,4061]},{"text":" });","type":"Line","range":[4064,4070]},{"text":" it(\"should trigger effect w/ setter\", () => {","type":"Line","range":[4074,4122]},{"text":"   const n = ref(1);","type":"Line","range":[4125,4147]},{"text":"   const plusOne = computed({","type":"Line","range":[4150,4181]},{"text":"     get: () => n.value + 1,","type":"Line","range":[4184,4214]},{"text":"     set: val => {","type":"Line","range":[4217,4237]},{"text":"       n.value = val - 1;","type":"Line","range":[4240,4267]},{"text":"     },","type":"Line","range":[4270,4279]},{"text":"   });","type":"Line","range":[4282,4290]},{"text":"   let dummy;","type":"Line","range":[4294,4309]},{"text":"   effect(() => {","type":"Line","range":[4312,4331]},{"text":"     dummy = n.value;","type":"Line","range":[4334,4357]},{"text":"   });","type":"Line","range":[4360,4368]},{"text":"   expect(dummy).toBe(1);","type":"Line","range":[4371,4398]},{"text":"   plusOne.value = 0;","type":"Line","range":[4402,4425]},{"text":"   expect(dummy).toBe(-1);","type":"Line","range":[4428,4456]},{"text":" });","type":"Line","range":[4459,4465]},{"text":" it(\"should warn if trying to set a readonly computed\", () => {","type":"Line","range":[4469,4534]},{"text":"   const n = ref(1);","type":"Line","range":[4537,4559]},{"text":"   const plusOne = computed(() => n.value + 1);","type":"Line","range":[4562,4611]},{"text":"   (plusOne as WritableComputedRef<number>).value++; // Type cast to prevent TS from preventing the error","type":"Line","range":[4614,4721]},{"text":"   expect(","type":"Line","range":[4725,4737]},{"text":"     \"Write operation failed: computed value is readonly\"","type":"Line","range":[4740,4799]},{"text":"   ).toHaveBeenWarnedLast();","type":"Line","range":[4802,4832]},{"text":" });","type":"Line","range":[4835,4841]}]}